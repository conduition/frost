//! Contains BIP32 key derivation logic for FROST groups.
//!
//! [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) is a specification
//! for hierarchical deterministic (HD) wallets, which use data structures called 'extended public keys'
//! (AKA 'xpubs') to derive numerous child keys.
//!
//! FROST groups can create HD wallets from their group [`VerifyingKey`], and so give out xpubs for
//! which the group can sign. An xpub generated by a FROST group looks no different than any other
//! xpub generated by a single-signer wallet.
//!
//! To generate an account-level xpub, use [`ExtendedPubkey::new`]. This hashes the group's [`VerifyingKey`]
//! into a tweak and chaincode, much like BIP32's master-node derivation from a seed. This is used to
//! synthesize an xpub which emulates a regular taproot account-level xpub ('account-level' in the
//! [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) sense). Imagine this as an xpub
//! derived at path `m/86'/0'/0'`.
//!
//! Further child xpubs and pubkeys can be derived from that account-level xpub using the
//! [`ExtendedPubkey::child`] or [`ExtendedPubkey::derive`] methods.

use super::{hasher_to_scalar, tagged_hash, Secp256K1Group, Secp256K1ScalarField, VerifyingKey};

use frost_core::{Field, Group};
use hmac::{Hmac, Mac};
use k256::{ProjectivePoint, Scalar};
use ripemd::Ripemd160;
use sha2::{Digest, Sha256, Sha512};

/// Keys can only be derived with indexes above `HARDENED_OFFSET` if the corresponding
/// secret key is known.
pub const HARDENED_OFFSET: u32 = 0x80000000;

/// Represents a [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) extended
/// public key.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ExtendedPubkey {
    /// The elliptic curve point used for payment and ownership proof.
    pub public_key: ProjectivePoint,
    /// The BIP32 chain code (additional entropy).
    pub chain_code: [u8; 32],
    /// The number of derivation steps from the hypothetical master key.
    pub depth: u8,
    /// The most recently derived child index. Should always be less than [`HARDENED_OFFSET`]
    pub child_number: u32,
    /// A truncated hash of the parent public key above this key in the hierarchy.
    pub parent_fingerprint: [u8; 4],
    /// Tracks the BIP32 tweak scalar sum, so we can tweak signatures. For internal use only.
    pub(crate) tweak_acc: Scalar,
}

/// Possible errors which can occur during BIP32 key derivation.
#[derive(thiserror::Error, Debug, Clone, Copy, Eq, PartialEq)]
pub enum Error {
    /// We received a hardened child key index.
    #[error("found hardened child key index; cannot derive hardened child keys from an xpub")]
    HardenedIndex,
    /// We derived an invalid tweak value. Exceedingly rare.
    #[error("derived invalid child key")]
    InvalidChildKey,
    /// We tried to derive a child key beyond a depth which can be represented as u8.
    #[error("child key would exceed maximum depth of 0xFF")]
    MaxDepthExceeded,
}

impl ExtendedPubkey {
    /// Construct a BIP32 extended public key by hashing the group's master verifying key.
    pub fn new(group_master_pubkey: &VerifyingKey) -> ExtendedPubkey {
        let vk = group_master_pubkey.to_element();
        let master_key_seralized = Secp256K1Group::serialize(&vk);

        // b = H_tweak(M)
        let initial_tweak =
            hasher_to_scalar(tagged_hash("FROST/BIP32-tweak").chain_update(master_key_seralized));

        // c = H_chaincode(M)
        let chain_code: [u8; 32] = tagged_hash("FROST/BIP32-chaincode")
            .chain_update(master_key_seralized) // TODO more parameters?
            .finalize()
            .into();

        // M' = M + b*G
        let public_key = vk + ProjectivePoint::GENERATOR * initial_tweak;

        // Emulate a `m/86'/0'/0'` xpub
        ExtendedPubkey {
            chain_code,
            public_key,
            depth: 3,
            child_number: HARDENED_OFFSET,
            parent_fingerprint: key_fingerprint(vk),
            tweak_acc: initial_tweak,
        }
    }

    /// Derive a child xpub at the given index.
    pub fn child(&self, index: u32) -> Result<ExtendedPubkey, Error> {
        if index >= HARDENED_OFFSET {
            return Err(Error::HardenedIndex);
        } else if self.depth == 0xFF {
            return Err(Error::MaxDepthExceeded);
        }

        // We can't use a third party library to do the BIP32 derivation unfortunately, due to a
        // lack of visibility into the tweak scalars used. Most BIP32 libraries just throw those
        // away. We need the tweak scalars to be able to modify our signatures.
        let mac = Hmac::<Sha512>::new_from_slice(&self.chain_code)
            .expect("HMAC initialization never fails")
            .chain_update(&Secp256K1Group::serialize(&self.public_key))
            .chain_update(&index.to_be_bytes())
            .finalize()
            .into_bytes();

        let (left, right) = mac.split_at(32);
        let left_array = <[u8; 32]>::try_from(left).expect("always correct size");
        let right_array = <[u8; 32]>::try_from(right).expect("always correct size");

        let t =
            Secp256K1ScalarField::deserialize(&left_array).map_err(|_| Error::InvalidChildKey)?;

        let xpub = ExtendedPubkey {
            chain_code: right_array,
            public_key: self.public_key + ProjectivePoint::GENERATOR * t,
            depth: self.depth + 1,
            child_number: index,
            parent_fingerprint: key_fingerprint(self.public_key),
            tweak_acc: self.tweak_acc + t,
        };
        Ok(xpub)
    }

    /// Derive a child xpub at a given key path.
    pub fn derive(&self, key_path: &[u32]) -> Result<ExtendedPubkey, Error> {
        if key_path.len() + (self.depth as usize) >= 0xFF {
            return Err(Error::MaxDepthExceeded);
        }
        for &index in key_path {
            if index >= HARDENED_OFFSET {
                return Err(Error::HardenedIndex);
            }
        }

        let mut xpub = self.clone();
        for &index in key_path {
            xpub = xpub.child(index)?;
        }
        Ok(xpub)
    }
}

/// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#user-content-Key_identifiers
fn key_fingerprint(pubkey: ProjectivePoint) -> [u8; 4] {
    let digest = Ripemd160::digest(Sha256::digest(Secp256K1Group::serialize(&pubkey)));
    <[u8; 4]>::try_from(&digest[..4]).expect("always correct size")
}
