//! Contains BIP32 key derivation logic for FROST groups.
//!
//! [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) is a specification
//! for hierarchical deterministic (HD) wallets, which use data structures called 'extended public keys'
//! (AKA 'xpubs') to derive numerous child keys.
//!
//! FROST groups can create HD wallets from their group [`VerifyingKey`], and so give out xpubs for
//! which the group can sign. An xpub generated by a FROST group looks no different than any other
//! xpub generated by a single-signer wallet.
//!
//! To generate an account-level xpub ('account-level' in the
//! [BIP44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki) sense),
//! use [`ExtendedPubkey::new`]. This hashes the group's [`VerifyingKey`] into a tweak and
//! chaincode, much like BIP32's master-node derivation from a seed. This is used to synthesize
//! an xpub which emulates a regular taproot account-level xpub. Imagine this as an xpub
//! derived at path `m/86'/0'/0'`, with a depth of 3 and a child index of [`HARDENED_OFFSET`].
//!
//! Further child xpubs and pubkeys can be derived from that account-level xpub using the
//! [`ExtendedPubkey::child`] or [`ExtendedPubkey::derive`] methods.
//!
//! The [`KeyPath`] type can be used to represent BIP32 key derivation paths with fixed maximum
//! sizes (for type-system enforcement of BIP32's depth limit of 255). [`ChildIndex`] wraps u32
//! to ensure key indexes cannot be hardened.

use super::{hasher_to_scalar, tagged_hash, Secp256K1Group, Secp256K1ScalarField, VerifyingKey};

use frost_core::{Field, Group};
use hmac::{Hmac, Mac};
use k256::{ProjectivePoint, Scalar};
use ripemd::Ripemd160;
use serde::{de::Error as _, Deserialize, Deserializer, Serialize, Serializer};
use sha2::{Digest, Sha256, Sha512};

/// Keys can only be derived with indexes above `HARDENED_OFFSET` if the corresponding
/// secret key is known.
pub const HARDENED_OFFSET: u32 = 0x80000000;

/// The mainnet `xpub...` prefix.
pub const NETWORK_VERSION_XPUB: [u8; 4] = [0x04, 0x88, 0xB2, 0x1E];
/// The testnet `tpub...` prefix.
pub const NETWORK_VERSION_TPUB: [u8; 4] = [0x04, 0x35, 0x87, 0xCF];

/// Possible errors which can occur during BIP32 [`KeyPath`] or [`ChildIndex`] construction.
#[derive(thiserror::Error, Debug, Clone, Copy, Eq, PartialEq)]
pub enum KeyPathError {
    /// We received a hardened child key index.
    #[error("found hardened child key index; cannot derive hardened child keys from an xpub")]
    HardenedIndex,
    /// We tried to derive a child key beyond a depth which this type of `KeyPath` can handle.
    #[error("key path would exceed maximum size")]
    MaxKeyPathSizeExceeded,
}

/// Represents an unhardened child index.
#[derive(Clone, Copy, Default, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]
#[cfg_attr(feature = "serde", derive(Serialize))]
pub struct ChildIndex(u32);

impl ChildIndex {
    /// The maximum allowed unhardened child index.
    pub const MAX: ChildIndex = ChildIndex(HARDENED_OFFSET - 1);
    /// The minimum allowed unhardened child index.
    pub const MIN: ChildIndex = ChildIndex(0);
}

impl From<ChildIndex> for u32 {
    fn from(value: ChildIndex) -> Self {
        value.0
    }
}

impl From<u16> for ChildIndex {
    fn from(value: u16) -> Self {
        ChildIndex(value as u32)
    }
}

impl TryFrom<u32> for ChildIndex {
    type Error = KeyPathError;

    fn try_from(value: u32) -> Result<Self, Self::Error> {
        if value >= HARDENED_OFFSET {
            return Err(KeyPathError::HardenedIndex);
        }
        Ok(ChildIndex(value))
    }
}

/// Deserialize is manually implemented to ensure that a deserialized ChildIndex cannot exceed
/// [`HARDENED_OFFSET`].
#[cfg(feature = "serde")]
impl<'de> Deserialize<'de> for ChildIndex {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<ChildIndex, D::Error> {
        #[derive(Deserialize)]
        struct ChildIndexFake(u32);

        let ChildIndexFake(index) = ChildIndexFake::deserialize(deserializer)?;
        ChildIndex::try_from(index).map_err(|_| {
            D::Error::invalid_value(
                serde::de::Unexpected::Other("hardened child index (>=0x80000000)"),
                &"an unhardened child index (below 0x80000000)",
            )
        })
    }
}

/// Represents a BIP32 key derivation path of a specific maximum length.
///
/// The `MAX_SIZE` constant parameter determines the maximum number of
/// key path elements which can be represented. `KeyPath` allocates an array
/// of this fixed size, containing elements of type [`ChildIndex`]. `KeyPath`
/// can be referenced as a `&[ChildIndex]` using its `AsRef` implementation.
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash)]
pub struct KeyPath<const MAX_SIZE: usize> {
    elements: [ChildIndex; MAX_SIZE],
    count: usize,
}

impl<const MAX_SIZE: usize> TryFrom<&[u32]> for KeyPath<MAX_SIZE> {
    type Error = KeyPathError;

    /// Converts a slice of `u32` into a [`KeyPath`]. Each element is checked
    /// to ensure it is not a hardened child index, and the slice length is
    /// checked to ensure it would not exceed the `MAX_SIZE` of the `KeyPath`
    /// type.
    fn try_from(nums: &[u32]) -> Result<Self, Self::Error> {
        if nums.len() > MAX_SIZE {
            return Err(KeyPathError::MaxKeyPathSizeExceeded);
        }
        let mut elements = [ChildIndex::MIN; MAX_SIZE];
        for (i, &n) in nums.iter().enumerate() {
            elements[i] = ChildIndex::try_from(n)?;
        }
        let kp = KeyPath {
            elements,
            count: nums.len(),
        };
        Ok(kp)
    }
}

impl<const MAX_SIZE: usize> TryFrom<&[ChildIndex]> for KeyPath<MAX_SIZE> {
    type Error = KeyPathError;

    /// Converts a slice of [`ChildIndex`] into a [`KeyPath`]. Each element
    /// is already guaranteed not to be a hardened child index, but the slice
    /// length is still checked to ensure it would not exceed the `MAX_SIZE` of
    /// the `KeyPath` type.
    fn try_from(indexes: &[ChildIndex]) -> Result<Self, Self::Error> {
        if indexes.len() > MAX_SIZE {
            return Err(KeyPathError::MaxKeyPathSizeExceeded);
        }
        let mut elements = [ChildIndex::MIN; MAX_SIZE];
        for (i, &index) in indexes.iter().enumerate() {
            elements[i] = index;
        }
        let kp = KeyPath {
            elements,
            count: indexes.len(),
        };
        Ok(kp)
    }
}

impl<const MAX_SIZE: usize> AsRef<[ChildIndex]> for KeyPath<MAX_SIZE> {
    /// Returns a slice reference to the key path's indexes.
    fn as_ref(&self) -> &[ChildIndex] {
        &self.elements[..self.count]
    }
}

#[cfg(feature = "serde")]
impl<const MAX_SIZE: usize> Serialize for KeyPath<MAX_SIZE> {
    /// Serializes the key path as a sequence of u32s.
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        self.as_ref().serialize(serializer)
    }
}

#[cfg(feature = "serde")]
impl<'de, const MAX_SIZE: usize> Deserialize<'de> for KeyPath<MAX_SIZE> {
    fn deserialize<D: Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        let nums = Vec::<ChildIndex>::deserialize(deserializer)?;

        KeyPath::try_from(nums.as_slice()).map_err(|e| match e {
            KeyPathError::HardenedIndex => unreachable!("indexes cannot be hardened here"),
            KeyPathError::MaxKeyPathSizeExceeded => D::Error::invalid_length(
                nums.len(),
                &format!("key path of length {MAX_SIZE} or smaller").as_str(),
            ),
        })
    }
}

/// Constructs a [`KeyPath`] using the following syntax:
///
/// ```
/// use frost_secp256k1_tr::{bip32::KeyPath, key_path};
/// let kp: KeyPath<100> = key_path!(vk / 0 / 1);
/// assert_eq!(kp, KeyPath::try_from([0, 1].as_ref()).unwrap());
/// ```
///
/// Using hardened key path elements or providing too many elements (exceeding the MAX_SIZE of the
/// `KeyPath` type you're creating) will cause a panic.
#[macro_export]
macro_rules! key_path {
    (vk/$j:literal$(/$i:literal)*) => {
        frost_secp256k1_tr::bip32::KeyPath::try_from([$j$(, $i)*].as_ref())
            .expect("invalid elements in key_path macro")
    };
}

/// Represents a [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) extended
/// public key derived from a FROST group verifying key.
#[derive(Clone, Debug, Eq, PartialEq)]
pub struct ExtendedPubkey {
    /// The 4-byte network version number used to produce a specific base58check-encoded prefix.
    pub network_version: [u8; 4],
    /// The elliptic curve point used for payment and ownership proof.
    pub public_key: ProjectivePoint,
    /// The BIP32 chain code (additional entropy).
    pub chain_code: [u8; 32],
    /// The number of derivation steps from the hypothetical master key.
    pub depth: u8,
    /// The most recently derived child index. Should always be less than [`HARDENED_OFFSET`]
    pub child_number: u32,
    /// A truncated hash of the parent public key above this key in the hierarchy.
    pub parent_fingerprint: [u8; 4],
    /// Tracks the BIP32 tweak scalar sum, so we can tweak signatures. For internal use only.
    pub(crate) tweak_acc: Scalar,
}

/// Possible errors which can occur during BIP32 key derivation.
#[derive(thiserror::Error, Debug, Clone, Copy, Eq, PartialEq)]
pub enum DeriveError {
    /// We derived an invalid tweak value. Exceedingly rare.
    #[error("derived invalid child key")]
    InvalidChildKey,
    /// We tried to derive a child key beyond a depth which can be represented as u8.
    #[error("child key would exceed maximum depth of 0xFF")]
    MaxDepthExceeded,
}

impl ExtendedPubkey {
    /// Construct a BIP32 extended public key by hashing the group's master verifying key.
    pub fn new(group_master_pubkey: &VerifyingKey, network_version: [u8; 4]) -> ExtendedPubkey {
        let vk = group_master_pubkey.to_element();
        let master_key_seralized = Secp256K1Group::serialize(&vk);

        // b = H_tweak(M)
        let initial_tweak =
            hasher_to_scalar(tagged_hash("FROST/BIP32-tweak").chain_update(master_key_seralized));

        // c = H_chaincode(M)
        let chain_code: [u8; 32] = tagged_hash("FROST/BIP32-chaincode")
            .chain_update(master_key_seralized) // TODO more parameters?
            .finalize()
            .into();

        // M' = M + b*G
        let public_key = vk + ProjectivePoint::GENERATOR * initial_tweak;

        // Emulate a m/86'/0'/0' xpub
        ExtendedPubkey {
            network_version,
            chain_code,
            public_key,
            depth: 3,
            child_number: HARDENED_OFFSET,
            parent_fingerprint: key_fingerprint(vk),
            tweak_acc: initial_tweak,
        }
    }

    /// Derive a child xpub at the given index.
    pub fn child(&self, index: ChildIndex) -> Result<ExtendedPubkey, DeriveError> {
        if self.depth == 0xFF {
            return Err(DeriveError::MaxDepthExceeded);
        }

        // We can't use a third party library to do the BIP32 derivation unfortunately, due to a
        // lack of visibility into the tweak scalars used. Most BIP32 libraries just throw those
        // away. We need the tweak scalars to be able to modify our signatures.
        let mac = Hmac::<Sha512>::new_from_slice(&self.chain_code)
            .expect("HMAC initialization never fails")
            .chain_update(&Secp256K1Group::serialize(&self.public_key))
            .chain_update(&u32::from(index).to_be_bytes())
            .finalize()
            .into_bytes();

        let (left, right) = mac.split_at(32);
        let left_array = <[u8; 32]>::try_from(left).expect("always correct size");
        let right_array = <[u8; 32]>::try_from(right).expect("always correct size");

        // The probability of this error occurring in the real world is miniscule.
        // (approx 1 in 2^128 for each derivation)
        let t = Secp256K1ScalarField::deserialize(&left_array)
            .map_err(|_| DeriveError::InvalidChildKey)?;

        let xpub = ExtendedPubkey {
            network_version: self.network_version,
            chain_code: right_array,
            public_key: self.public_key + ProjectivePoint::GENERATOR * t,
            depth: self.depth + 1,
            child_number: u32::from(index),
            parent_fingerprint: key_fingerprint(self.public_key),
            tweak_acc: self.tweak_acc + t,
        };
        Ok(xpub)
    }

    /// Derive a child xpub at a given key path.
    pub fn derive(&self, key_path: &[ChildIndex]) -> Result<ExtendedPubkey, DeriveError> {
        if key_path.len() + (self.depth as usize) >= 0xFF {
            return Err(DeriveError::MaxDepthExceeded);
        }

        let mut xpub = self.clone();
        for &index in key_path {
            xpub = xpub.child(index)?;
        }
        Ok(xpub)
    }

    /// Serialize the xpub into a fixed-length byte array. The `network_version` determines the prefix
    /// of the xpub once it is encoded as base58.
    pub fn to_bytes(&self) -> [u8; 78] {
        let mut buf = [0u8; 78];
        buf[0..4].copy_from_slice(&self.network_version);
        buf[4] = self.depth;
        buf[5..9].copy_from_slice(&self.parent_fingerprint);
        buf[9..13].copy_from_slice(&u32::from(self.child_number).to_be_bytes());
        buf[13..45].copy_from_slice(&self.chain_code[..]);
        buf[45..78].copy_from_slice(&Secp256K1Group::serialize(&self.public_key));
        buf
    }

    /// Serialize the xpub into a fixed-length byte array and then base58-check encode it for
    /// easy distribution to BIP32 clients. The `network_version` determines the prefix of the
    /// serialized xpub.
    ///
    /// ```
    /// use frost_secp256k1_tr::{bip32, VerifyingKey};
    /// use hex::FromHex;
    ///
    /// let vk = VerifyingKey::from_hex("0265a0578d696c6f475468458700a273d99c39edb0819d3fe3327aa8251d3df2e4").unwrap();
    /// let xpub = bip32::ExtendedPubkey::new(&vk, bip32::NETWORK_VERSION_XPUB);
    /// assert_eq!(
    ///     xpub.to_base58(),
    ///     "xpub6DTAAS87qxjh5VzAEr1SdXssEpPBxxKXvGEpTvRxxd9KJMmrsEzqwWs87AHHrnrawQa9GC1xPt3jVHbbHGm9R2m5XpJwT2Red3gYyEA6yVR",
    /// );
    /// ```
    pub fn to_base58(&self) -> String {
        bs58::encode(self.to_bytes()).with_check().into_string()
    }
}

#[cfg(feature = "serde")]
impl Serialize for ExtendedPubkey {
    /// Serializes the ExtendedPubkey as its base58check-encoded serialization if the data
    /// format is human-readable, or as a byte array otherwise.
    fn serialize<S: Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        if serializer.is_human_readable() {
            self.to_base58().serialize(serializer)
        } else {
            self.to_bytes().serialize(serializer)
        }
    }
}

impl std::fmt::Display for ExtendedPubkey {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        self.to_base58().fmt(f)
    }
}

/// https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#user-content-Key_identifiers
fn key_fingerprint(pubkey: ProjectivePoint) -> [u8; 4] {
    let digest = Ripemd160::digest(Sha256::digest(Secp256K1Group::serialize(&pubkey)));
    <[u8; 4]>::try_from(&digest[..4]).expect("always correct size")
}
